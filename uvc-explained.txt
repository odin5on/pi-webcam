I'm just summarizing how this works so I can try and understand it.


/src/main.c

Processes all of the arguments. Creates a source based on the arguments given (libcamera, v4l2device, slideshow...). This creates a video_soure struct which is passed to some other funcions later.


/lib/v4l2-source.c

struct video_source *v4l2_video_source_create(const char *devname)
What this function does:

	1. Takes a string (devname) which is the path to the video src
	2. Allocates memory for a new v4l2_source which contains a video_source struct and v4l2_device 
	   struct
	3. Sets the ops field of the video_source to a defined video_source_ops struct
	4. Sets the type field of the video_source to VIDEO_SOURCE_DMABUF, this presumably means the source
	   uses DMA-BUF for memory management
	5. It tries to open the device, if this fails it frees the source from memory and returns null
	6. It checks the type of the v4l2_device to make sure it is V4L2_BUF_TYPE_VIDEO_CAPTURE, if not
	   it causes an error and returns.
	7. If everything is successful, it returns a pointer to src (the v4l2_source)


/lib/libcamera-source.cpp

stuct video_source *libcamera_source_create(const char *devname)
What this function does:

	1. Takes a string (devname) which is the "camera identifier" (Usually this is just "0" which is the
	   index of the first camera
	2. Creates a new libcamera_src object (which has a video_source struct, same as v4l2-source)
	3. Line 510: pipe2(src->pfds, O_NONBLOCK); described in the following paragraph

	This line of code is calling the pipe2 function to create a pipe, which is a mechanism for 
	interprocess communication (IPC) in Unix-like operating systems. A pipe provides a one-way 
	communication channel between two processes: one process writes data to the pipe, and the other 
	process reads that data.

	The pipe2 function takes two arguments:

	An array of two integers, src->pfds in this case, where the function will store the file 
	descriptors for the read end and write end of the pipe. After the function call, src->pfds[0] 
	will be the file descriptor for the read end of the pipe, and src->pfds[1] will be the file 
	descriptor for the write end.

	A set of flags that modify the behavior of the pipe. In this case, O_NONBLOCK is passed, which 
	means that the pipe is set to non-blocking mode. In non-blocking mode, read and write operations 
	on the pipe will return immediately rather than waiting for data to be available or for space to be 
	available for writing.

	The pipe2 function returns an integer, ret in this case, which is 0 on success and -1 on error. If 
	the function returns -1, an error occurred and the error code can be retrieved with errno.

	4. Sets the ops field o fthe video_source to a defined libcamera_source_ops struct]
	5. Sets the type field of video_source to VIDEO_SOURCE_DMABUF
	6. Creates and starts a CameraManager object which is assigned to the libcamera_src (not sure what
	   the CameraManager object is/does
	7. Finds the camera object through a somewhat complicated way of querying the cameras based on the
	   index you pass in (usually 0)
	8. Configures the camera through some generateConfiguration function that I need to figure out
	   what it does.
	9. Connects to the requestComplete method to the requestCompleted signal of the camera
	10. If everything is successful, returns a pointer to the src (libcamera_source)

 
